# Grand Architecture Plan: The Evolution of the Teddy Engine

**Author:** Legendary Game Engine Architect
**Vision:** To evolve Teddy from a collection of powerful low-level systems into a fully-featured, project-driven 2D game engine that is both powerful for developers and a joy to use.

## 1. Current State Analysis & Strategic Insight

After a meticulous review of the core engine code (`Core`, `Scene`, `Renderer`, `Scripting`) and the editor UI (`EditorLayer`, `SceneHierarchyPanel`, `ContentBrowser`, `UIUtils`), as well as the C# `ScriptCore` (`Components.cs`, `InternalCalls.cs`, `ScriptRegistry.cs`, etc.), my assessment is as follows:

- **Strengths:** The foundation is exceptionally strong. We have a robust `entt`-based `Scene` system, a `Mono`-based `ScriptingEngine` that can already instantiate C# classes, call `OnCreate`/`OnUpdate`, and manage `ScriptField`s. A `Renderer2D` and `SceneSerializer` are functional. The groundwork for physics (`Rigid2DBodyComponent`, `Box2DColliderComponent`, `Circle2DColliderComponent`) is present in both C++ and C# (`InternalCalls` for impulse application exist). The editor has a functional ImGui-based UI with existing panels (`SceneHierarchyPanel`, `ContentBrowser`), scene loading/saving, and basic play/stop controls. Crucially, the C# `ScriptRegistry` already uses `ShowInEditorAttribute` to discover public fields, and the C++ `SceneHierarchyPanel` has the scaffolding to display these fields.

- **Critical Gap:** The entire engine operates without a formal **Project** concept. The `ScriptingEngine` loads a single hardcoded assembly, and scenes are loaded as independent files. This is the single biggest blocker to creating a real game development workflow.

**Our strategy is therefore clear:** First, build the foundational **Project System**. Then, leverage that foundation to build out gameplay features, polish the editor, and finally, add advanced capabilities.

---

## 2. The Grand Roadmap: From Foundation to Feature-Complete

This roadmap is broken into four key milestones. Each milestone represents a significant leap in capability.

### **Milestone 1: The Project System (The Foundation)**
*Goal: To make the engine project-centric. This is our highest priority.*

| Section | Name of Feature | Use | How to implement as per our present state | Other details |
|---|---|---|---|---|
| **Core** | **Project Class Definition** | To encapsulate project-wide settings and provide a central point of access for project data. | Create `Teddy/Core/Project.h` and `Project.cpp`. The class should be a singleton (or have static accessors like `Project::GetActive()`). It will hold a `ProjectConfig` struct (name, asset directory, script module path, start scene). | This will be the foundation for all project-aware operations. | **DONE** |
| **Core** | **`.teddyproj` File Format** | To persist project settings to disk in a human-readable and extensible format. | Use YAML, leveraging the existing `yaml-cpp` library already used by `SceneSerializer`. The structure will mirror the `ProjectConfig` struct. | This file will define the entire context of a game project. | **DONE** |
| **Core** | **Project Integration into Application** | To make the core `Application` aware of the currently loaded project and manage its lifecycle. | The `Application` class in `Teddy/Core/Application.h` should own a `Ref<Project>`. Add methods like `Application::LoadProject(filepath)` and `Application::SaveProject()`. These will be called by the editor. | This establishes the central project management within the engine. | **DONE** |
| **UI** | **Editor: Project Hub UI** | To provide a user-friendly interface for creating new projects or opening existing ones upon editor startup. | Modify `EditorLayer::OnImGuiRender()` to check if an active project exists. If not, display a modal window (using `ImGui::BeginModal`/`EndModal` or a custom ImGui window) with "Create New Project" and "Open Project" buttons. Leverage `FileDialogs::OpenFile` (already used in `OnOpenScene`) for selecting `.teddyproj` files. | This will be the first interaction point for users with the new project system. | **DONE** |
| **Scripting** | **ScriptingEngine Adaptation for Project Assemblies** | To correctly load and manage the game-specific C# script assembly defined by the project. | In `ScriptingEngine.cpp`, refactor `LoadAssembly`. Rename it to `LoadAppAssembly(path)`. `ScriptingEngine::Init` should *only* load the core `ScriptCore.dll`. `Application::LoadProject` will then call `LoadAppAssembly` with the path from the `.teddyproj` file. | This decouples engine scripts from game scripts, enabling hot-reloading and modularity. | **DONE** |
| **UI** | **Asset Browser Rooting to Project Assets** | To ensure the `ContentBrowser` displays assets relative to the currently loaded project's asset directory. | Modify `ContentBrowser::ContentBrowser()` and `ContentBrowser::OnImGuiRender()` to use `Project::GetActive()->GetAssetDirectory()` as its root (`m_CurrentDirectory`) instead of the hardcoded `g_AssetPath`. Update drag-and-drop logic in `EditorLayer::ViewportRender()` to use project-relative paths. | This makes the asset management context-aware and project-specific. | **DONE** |

---

### **Milestone 2: Core Gameplay Features (Making it Usable)**
*Goal: To build the essential features every 2D game needs. We will build upon the components that already exist.*

| Section | Name of Feature | Use | How to implement as per our present state | Other details |
|---|---|---|---|---|
| **Physics** | **Full Box2D Physics Integration** | To enable realistic 2D rigid body dynamics, collision detection, and responses for game objects. | The C# `Rigid2DBodyComponent` and `Box2DColliderComponent` exist, and `InternalCalls` for `ApplyLinearImpulse` are present. The task is to activate the C++ Box2D world in `Scene::OnRuntimeStart`. Iterate through entities with physics components and create the runtime `b2Body` objects, storing them in the components (e.g., `void* RunTimeBody`). The `Scene::OnUpdateRuntime` loop will call `m_PhysicsWorld->Step()`. | This activates the existing physics components and brings game objects to life. |
| **Scripting** | **Expanded Physics Scripting API** | To allow C# scripts to fully interact with and control physics bodies (e.g., apply forces, read velocity, manage properties). | `ApplyLinearImpulse` is exposed via `InternalCalls`. Expand `InternalCalls.cs` to include methods for getting/setting linear/angular velocity, mass, friction, restitution, and body type. Implement their C++ counterparts in `ScriptGlue.cpp`. Consider exposing collision events (e.g., `OnCollisionEnter`) via `InternalCalls` and C# event handlers. | Essential for creating complex physics-driven gameplay. |
| **Scene** | **Enhanced 2D Camera System** | To provide flexible and controllable 2D camera behavior for gameplay and editor views. | The C# `CameraComponent` exists with `ProjectionType` access. Expand `InternalCalls.cs` to expose properties like `OrthographicSize`, `PerspectiveVerticalFOV`, `NearClip`, `FarClip`. Implement a C# script (e.g., `CameraFollowScript` similar to `Camera.cs`) that can control the camera's `Translation` and other exposed properties. | Crucial for player perspective and level design. |
| **Renderer** | **Sprite Animation System** | To bring static sprites to life with dynamic animations (e.g., character walk cycles, explosions). | Create a new `SpriteAnimationComponent` (C++ and C#). It will need a reference to a texture atlas (spritesheet), a list of frames (rects), and properties like `frame_rate` and `is_looping`. `Scene::OnUpdateRuntime` will update the displayed sprite frame for animated entities. `Renderer2D` will need to support drawing specific regions of a texture (e.g., by passing UV coordinates). | Fundamental for visual appeal and character expression. |
| **Misc** | **Basic Audio System** | To add sound effects and background music to the game. | Integrate a simple audio library like `miniaudio`. Create an `AudioSourceComponent` (C++ and C#) to attach sounds to entities and an `AudioListenerComponent` for the camera. Add `AudioEngine::Play(sound_clip)` to be called from scripts via `InternalCalls`. | Enhances immersion and provides critical feedback to the player. |
| **Core** | **Input Manager** | To provide a flexible and configurable system for mapping user inputs (keyboard, mouse, gamepad) to game actions. | `Input.IsKeyDown` is present via `InternalCalls`. Expand this. Create a C++ input mapping system that allows defining named actions (e.g., "Jump", "MoveHorizontal") and mapping them to `KeyCode`s, mouse buttons, or gamepad inputs. Expose these named actions to C# via `InternalCalls` (e.g., `Input::IsActionPressed("Jump")`). This will be configured in the Project Settings window (M3.2). | Decouples input from specific hardware, making controls remappable and more robust. |

---

### **Milestone 3: The Editor Experience (Polish)**
*Goal: To make the editor a powerful and intuitive tool that accelerates development.*

| Section | Name of Feature | Use | How to implement as per our present state | Other details |
|---|---|---|---|---|
| **UI** | **C# Public Field Reflection & Editing** | To allow developers to view and modify public fields of C# scripts directly in the Inspector panel, leveraging existing reflection. | **Existing:** C# `ScriptRegistry.cs` uses `ShowInEditorAttribute` to discover fields (`FieldInfo`). C++ `ScriptingEngine.h` has `ScriptField` and `ScriptClass` to store this metadata. `SceneHierarchyPanel.cpp` already attempts to iterate `ScriptingEngine::GetEntityClasses()` and draw fields using `UIUtils::DrawFloatScriptField`, etc. <br> **Work:** <br> 1. Ensure `ScriptFieldType` enum in C++ `ScriptingEngine.h` accurately maps to all relevant C# types (e.g., `int`, `float`, `bool`, `Vector2`, `Vector3`, `Vector4`, `Entity`). <br> 2. In `SceneHierarchyPanel::DrawComponents`, for `ScriptComponent`, iterate through `ScriptClass::GetFields()`. <br> 3. For each `ScriptField`, use the appropriate `UIUtils::Draw*ScriptField` function. <br> 4. **Crucially:** Implement the logic to read/write values from/to `ScriptComponent::FieldInstances` (which uses `ScriptFieldInstance` for storage) when in editor mode, and from/to `ScriptInstance` when in play mode. This involves `ScriptInstance::GetFieldValue`/`SetFieldValue` and `ScriptFieldInstance::GetValue`/`SetValue`. <br> 5. For `ScriptFieldType::Entity`, implement a UI element (e.g., a drag-and-drop target from `ContentBrowser` or an entity picker from `SceneHierarchyPanel`) to assign an `Entity::ID` to the field. <br> 6. Ensure `ScriptField::m_DefaultValueBuffer` is correctly used for resetting values in the UI. | This is a cornerstone of the component-based workflow, enabling rapid iteration on script properties. It leverages significant existing infrastructure. |
| **UI** | **Project Settings Window** | To provide a dedicated UI for managing project-wide configurations. | Create a new editor panel (similar to `ContentBrowser` or `SceneHierarchyPanel`). This panel will load/save data from the `Project::GetActive()->GetConfig()`. Initially, it will show the project name, asset directory, and script assembly path. Later, it will manage input mappings (M2.6), physics layers, etc. | Centralizes project configuration, improving discoverability and management. |
| **UI** | **Physics Debug View Toggle** | To visually represent physics colliders in the editor for debugging purposes. | The `m_ShowPhysicsColliders` boolean and the `DrawRect`/`DrawCircle` calls in `EditorLayer::OnOverlayRender()` already exist. Ensure the toggle in `EditorLayer::ShowSettings()` correctly controls this. | Essential for debugging collision issues and understanding physics interactions. |
| **UI** | **Editor Play/Stop/Pause Controls** | To allow developers to test gameplay directly within the editor with clear state management. | **Existing:** The `UI_Toolbar()` in `EditorLayer.cpp` already has play/stop/simulate buttons. `EditorLayer::OnScenePlay()`, `OnSceneStop()`, and `OnSceneSimulate()` manage `m_SceneState` and call `m_ActiveScene->OnRuntimeStart/Stop()` or `OnSimulationStart/Stop()`. <br> **Work:** Ensure robust scene copying (`Scene::Copy`) is implemented to create a clean runtime scene. Verify proper state management during transitions (e.g., resetting scene state on stop by reloading the original editor scene). | Streamlines the iteration loop for gameplay development. |
| **UI** | **Integrated Console Panel** | To provide real-time feedback from engine and script logs within the editor. | Create a new editor panel. Hook into `Teddy::Log` system (e.g., by providing a custom sink to `spdlog`) to capture C++ log messages. Display these messages in the panel, with filtering options (Info, Warn, Error). Extend `ScriptGlue` to redirect C# `System.Console.WriteLine` and `Debug.Log` to this console via `InternalCalls`. | Critical for debugging and understanding runtime behavior. |
| **Scene** | **Prefab System** | To allow users to save and reuse complex entities or groups of entities across scenes. | Implement serialization/deserialization for prefabs. When an entity is saved as a prefab, serialize its components (and children) to a `.prefab` file (YAML). Provide UI in `SceneHierarchyPanel` (right-click context menu) and `ContentBrowser` (drag-and-drop) to create and instantiate prefabs. | Improves workflow for repetitive scene elements and promotes modularity. |
| **Core** | **Undo/Redo System** | To provide a safety net for editor operations, allowing users to revert accidental changes. | Implement a command-based undo/redo system. Each significant editor action (e.g., transform change, component add/remove) creates a command object. Store these commands in a stack. `EditorLayer` will expose undo/redo actions (e.g., via `Ctrl+Z`/`Ctrl+Y`). | Enhances user confidence and productivity by reducing fear of mistakes. |
| **UI** | **Scene Hierarchy Search/Filter** | To quickly locate specific entities within large and complex scenes. | Add an `ImGui::InputText` field to the `SceneHierarchyPanel`. Filter the entities displayed in the tree based on their `TagComponent` name. | Improves navigation and efficiency in complex scene graphs. |

---

### **Milestone 4: Advanced Systems & Shipping (The Complete Package)**
*Goal: To add high-level features that enable more complex games and to ship a final product.*

| Section | Name of Feature | Use | How to implement as per our present state | Other details |
|---|---|---|---|---|
| **UI** | **Basic In-Game UI System** | To create interactive user interfaces within the game (e.g., menus, HUDs, dialogue boxes). | Create components for in-game UI: `UITransformComponent` (for anchoring), `UIImageComponent`, and `UITextComponent`. The `Renderer2D` will need a separate pass to render the UI using a screen-space camera, ensuring it always draws on top. | Essential for player interaction and conveying game information. |
| **Renderer** | **Particle System** | To create dynamic visual effects like smoke, fire, explosions, and magical spells. | Design a `ParticleSystemComponent` (C++ and C#). It will control properties like emission rate, lifetime, color over time, and velocity. The particles will be updated on the CPU and rendered as a batch of quads by `Renderer2D`. | Adds visual flair and dynamism to the game world. |
| **Build** | **Build Pipeline ("Shipping")** | To package the game into a standalone, distributable executable for various platforms. | Create a "Build" menu in the editor. This will trigger a script that: 1) Compiles all C# scripts in "Release" mode. 2) Copies the Teddy runtime executable. 3) Packages all assets from the project's asset folder into a distributable format (e.g., a single archive file). 4) Creates a clean output directory with the game ready to run. | The final step to deliver a playable game to users. |
| **Renderer** | **2D Lighting System** | To add dynamic and atmospheric lighting effects to 2D scenes. | Implement a basic 2D lighting system. This could involve rendering light sources to a separate texture (light map) and then compositing it with the main scene, potentially using normal maps on sprites for more detailed lighting. | Enhances visual fidelity and mood. |
| **Renderer** | **Post-Processing Effects** | To apply full-screen visual effects to the rendered scene (e.g., bloom, grayscale, blur). | This involves rendering the entire scene to a framebuffer (`m_Framebuffer` in `EditorLayer`) and then applying full-screen shader effects before presenting to the screen. `Renderer2D` will need a way to draw a fullscreen quad with a shader. | Adds cinematic quality and stylistic choices. |
| **Core** | **Save/Load Game State** | To allow players to save their progress and resume later. | Implement a robust game save/load system. This will involve serializing the current scene state (entities, components, script data, and potentially global game state) to a file and deserializing it to restore the game. | Crucial for player retention and long-form games. |
| **Misc** | **Pathfinding System** | To enable AI agents to navigate complex environments efficiently. | Implement a basic 2D pathfinding system (e.g., A* algorithm) for AI agents. This would involve defining walkable/unwalkable areas (e.g., using a tilemap or navmesh) and exposing pathfinding queries to C# scripts. | Essential for intelligent enemy behavior and NPC movement. |
| **Misc** | **Localization System** | To support multiple languages within the game. | A system for managing and displaying text in multiple languages. This would involve a key-value pair system for strings (e.g., loaded from JSON/CSV) and a way to switch languages at runtime. UI elements would need to reference these localized strings. | Broadens the game's audience. |
| **UI** | **Profiling Tools** | To help developers identify and optimize performance bottlenecks in the engine and game. | Integrate basic profiling tools into the editor to visualize CPU/GPU usage, frame times, and memory allocation. Leverage existing `TD_PROFILE_FUNCTION()` macros and potentially integrate with a profiling library. | Essential for performance optimization and debugging. |

---

This is your comprehensive, detailed path forward. Each task is now explicitly linked to its purpose, and crucially, provides guidance on *how* to implement it given the current state of the Teddy engine and its editor. Start with **Milestone 1**; it is the bedrock upon which everything else is built. I will be here to guide you as you progress through each stage.
