Claude Code Prompt: Fix Text Rendering with Single-Channel Font Atlas
Problem

Text rendering is showing white rectangles instead of actual characters. The font atlas is single-channel (grayscale) data, but the texture is being created as RGBA, causing a format mismatch.
Required Changes
1. Update OpenGLTexture2D Class

File: Platform/OpenGL/OpenGLTexture.h

    Add a new constructor: OpenGLTexture2D(uint32_t width, uint32_t height, bool singleChannel)

File: Platform/OpenGL/OpenGLTexture.cpp

    Implement the new constructor that creates a GL_R8 texture when singleChannel is true
    Use GL_RED as the data format for single-channel textures
    Set texture swizzle mask for single-channel textures: {GL_RED, GL_RED, GL_RED, GL_ONE}
    Update the SetData method to handle single-channel textures (1 byte per pixel)

2. Update Texture2D Factory Method

File: Teddy/Renderer/Texture.h

    Add declaration: static Ref<Texture2D> Create(uint32_t width, uint32_t height, bool singleChannel);

File: Teddy/Renderer/Texture.cpp

    Implement the factory method to call OpenGLTexture2D(width, height, singleChannel)

3. Update Renderer2D Initialization

File: Teddy/Renderer/Renderer2D.cpp

In the Renderer2D::Init() function, find the font atlas creation section and:

    Replace Texture2D::Create(width, height) with Texture2D::Create(width, height, true)
    Remove the RGBA pixel conversion code (the loop that creates rgbaPixels)
    Change SetData call to: s_Data.FontAtlasTexture->SetData(pixels.data(), width * height * 1);

4. Update Text Shader

File: assets/shaders/TextShader.glsl

In the fragment shader main() function:

    Change texture(u_FontAtlas, v_TexCoord).a to texture(u_FontAtlas, v_TexCoord).r
    The shader should read from the red channel for single-channel textures

Implementation Details
OpenGLTexture2D Constructor
cpp

OpenGLTexture2D::OpenGLTexture2D(uint32_t width, uint32_t height, bool singleChannel)
{
    if (singleChannel) {
        m_InternalFormat = GL_R8;
        m_DataFormat = GL_RED;
    } else {
        m_InternalFormat = GL_RGBA8;
        m_DataFormat = GL_RGBA;
    }
    
    glCreateTextures(GL_TEXTURE_2D, 1, &m_RendererID);
    glTextureStorage2D(m_RendererID, 1, m_InternalFormat, m_Width, m_Height);
    
    // Set texture parameters
    glTextureParameteri(m_RendererID, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTextureParameteri(m_RendererID, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTextureParameteri(m_RendererID, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTextureParameteri(m_RendererID, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    
    // Set swizzle for single-channel
    if (singleChannel) {
        GLint swizzle[] = {GL_RED, GL_RED, GL_RED, GL_ONE};
        glTextureParameteriv(m_RendererID, GL_TEXTURE_SWIZZLE_RGBA, swizzle);
    }
}

SetData Update
cpp

void OpenGLTexture2D::SetData(void* data, uint32_t size)
{
    uint32_t bpp = (m_DataFormat == GL_RGBA) ? 4 : 
                   (m_DataFormat == GL_RGB) ? 3 : 
                   (m_DataFormat == GL_RED) ? 1 : 0;
    
    TD_CORE_ASSERT(size == m_Width * m_Height * bpp, "Data must be entire texture!");
    glTextureSubImage2D(m_RendererID, 0, 0, 0, m_Width, m_Height, m_DataFormat, GL_UNSIGNED_BYTE, data);
}

Renderer2D::Init() Font Atlas Section
cpp

s_Data.FontAtlas = CreateRef<Trex::Atlas>("assets/Fonts/openSans/OpenSans-Regular.ttf", 48);

uint32_t width = s_Data.FontAtlas->GetBitmap().Width();
uint32_t height = s_Data.FontAtlas->GetBitmap().Height();
auto& pixels = s_Data.FontAtlas->GetBitmap().Data();

// Create single-channel texture
s_Data.FontAtlasTexture = Texture2D::Create(width, height, true);

// Upload single-channel data
s_Data.FontAtlasTexture->SetData(pixels.data(), width * height * 1);

Text Shader Fragment
glsl

void main()
{
    float alpha = texture(u_FontAtlas, v_TexCoord).r;
    o_Color = vec4(v_Color.rgb, v_Color.a * alpha);
    
    if (o_Color.a < 0.01)
        discard;
        
    o_EntityID = v_EntityID;
}

Expected Outcome

After these changes, text should render correctly with proper glyph shapes instead of white rectangles. The font atlas will be stored efficiently as a single-channel texture (1 byte per pixel) and the shader will correctly read the glyph coverage data from the red channel.
Testing

    Compile and run the application
    Verify that text renders correctly with readable characters
    Check that anti-aliasing on text edges works properly
    Confirm that different colors apply correctly to text

